<!DOCTYPE html>
<html>
	<head>
		<link href='http://fonts.googleapis.com/css?family=Open+Sans+Condensed:300' rel='stylesheet' type='text/css'>
		<link type="text/css" rel="stylesheet" href="../stylesheets/blog-stylesheet.css">
		<title>Alex Yanai Developer - Design</title>
	</head>
	<body>
		<section id="main">
			<header>
				<nav>
					<a href="../blogposts.html">Blog&#160;</a>
					<a href="../portfolio.html">Work</a>
				</nav>
			</header>

			<section id="left">
				<section id="title">
					<h2>Recursion</h2>
				</section>
				<section id="time">
					<p>October 16th, 2014</p>
				</section>
				<section id="blog">
					<section id="content">
						In Ruby, code can be grouped together and reused in the form of methods; pretty much any code can be inserted into a method block...including the method itself. For example, let's say we want to define a method to count up to 10:<br>

						<p class="block">
						&#160;&#160;def counting(n)<br>
						&#160;&#160;&#160;&#160;if n <= 10<br>
						&#160;&#160;&#160;&#160;&#160;&#160;counting(n+1)<br>
						&#160;&#160;&#160;&#160;end<br>
						&#160;&#160;end</p><br>

						Recursion is the technique wherein a method calls itself repeatedly in order to meet a condition. Any recursive function requires an ultimate condition, referred to as a 'base case', in order to end; the base case is the method call where the method does not call itself. Once the base case runs, all previous method calls are then run in relation to it. Using the above example, we can see what 'counting' would return given an argument of 1:<br><br>

						<p class="block">
						&#160;&#160;def counting(n)<br>
						&#160;&#160;&#160;&#160;if n <= 10<br>
						&#160;&#160;&#160;&#160;&#160;&#160;puts "Counting recursively! #{n}."<br>
						&#160;&#160;&#160;&#160;&#160;&#160;counting(n+1)<br>
						&#160;&#160;&#160;&#160;end<br>
						&#160;&#160;end<br><br>

						&#160;&#160;counting(1)<br><br>

						&#160;&#160;=>Counting recursively! 1.<br>
						&#160;&#160;&#160;&#160;Counting recursively! 2.<br>
						&#160;&#160;&#160;&#160;Counting recursively! 3.<br>
						&#160;&#160;&#160;&#160;Counting recursively! 4.<br>
						&#160;&#160;&#160;&#160;Counting recursively! 5.<br>
						&#160;&#160;&#160;&#160;Counting recursively! 6.<br>
						&#160;&#160;&#160;&#160;Counting recursively! 7.<br>
						&#160;&#160;&#160;&#160;Counting recursively! 8.<br>
						&#160;&#160;&#160;&#160;Counting recursively! 9.<br>
						&#160;&#160;&#160;&#160;Counting recursively! 10.</p><br>

						Though n=1 is the argument passed to the block, and it is the the first case listed, it is actually the last case returned. Understanding this is important to understanding the downsides to recursion; since all of calls before the base case rely on subsequent method calls, they are stored temporarily in the 'call stack'. This temporary storage is trivial in a single instance of a simple method, but can be a progressively larger burden on memory and processing power as complexity increases.<br><br>

						Iteration is The obvious alternative to recursion, and object oriented languages such as Ruby are generally designed to favor it over recursion ( some functional programming languages, on the other hand, don't have the ability to define iterative loops). The following example shows 2 methods to calculate the Fibonacci Sequence, written recursively and iteratively:<br><br>

						<p class="block">
						&#160;&#160;RECURSIVE:<br><br>
						&#160;&#160;def rec_fib(n)<br>
						&#160;&#160;&#160;&#160;return n if n <= 1<br>
						&#160;&#160;&#160;&#160;rec_fib(n - 1) + rec_fib(n - 2)<br>
						&#160;&#160;end<br><br>

						&#160;&#160;ITERATIVE:<br><br>
						&#160;&#160;def it_fib(n)<br>
						&#160;&#160;a, b, num = 1, 1, 1<br>
						&#160;&#160;while num < n<br>
						&#160;&#160;&#160;&#160;&#160;&#160;a, b = b, a + b<br>
						&#160;&#160;&#160;&#160;&#160;&#160;num += 1<br>
						&#160;&#160;&#160;&#160;end<br>
						&#160;&#160;&#160;&#160;return a<br>
						&#160;&#160;end</p><br>

						The method written using recursion is shorter and, due to the very nature of Fibonacci Sequence, seems more elegant - after all, it's a closer model to how the sequence is naturally calculated than the iterative method. The main issue can be seen when the two methods are run; we can define a test method to calculate the run time of each version:<br><br>

						<p class="block">
						&#160;&#160;def test<br>
						&#160;&#160;&#160;&#160;start = Time.now<br>
						&#160;&#160;&#160;&#160;yield<br>
						&#160;&#160;&#160;&#160;time = (Time.now - start) * 1000<br>
						&#160;&#160;&#160;&#160;puts "Total time: #{time}ms"<br>
						&#160;&#160;end</p><br>

						<p class="block">
						&#160;&#160;test{ rec_fib(5) }<br>
						&#160;&#160;=> Run time: 0.008993ms<br><br>

						&#160;&#160;test{ it_fib(5) }<br>
						&#160;&#160;=> Run time: 0.005075ms</p><br>

						The results are pretty clear: when calculating a Fibonacci Sequence to its 5th value (1,1,2,3,5), the iterative method is roughly 80% faster. Let's run another test, this time calculating the number 30 places into the sequence:<br><br>

						<p class="block">
						&#160;&#160;test{ rec_fib(30) }<br>
						&#160;&#160;=> Run time: 284.067793ms<br><br>

						&#160;&#160;test{ it_fib(30) }<br>
						&#160;&#160;=> Run time: 0.008672ms</p><br>

						The difference is dramatically more pronounced as the value of n, corresponding to the number of calls needed in the recursive case, increases, while the iterative method, at least relative to the recursive method, sees only a small run time increase. Recursion is shorter and often appears more elegant when written, but a programmer should always keep in mind the efficiency tradeoff that comes with its implementation.</section>
					<section id="share">
						<ul>
							<li>Connect:</li>
							<li><a href="https://www.linkedin.com/in/AlexYanai">LinkedIn</a></li>
							<li><a href="https://twitter.com/AlexSYanai">Twitter</a></li>
							<li><a href="https://www.github.com/AlexSYanai">Github</a></li>
							<li><a rel="author" href="https://plus.google.com/u/0/+AlexYanai?rel=author">Google+</a></li>
						</ul>
					</section>
				</section>
			</section>
			<footer><p>Alex Yanai - 2014</p></footer>
		</section>
	</body>
</html>
